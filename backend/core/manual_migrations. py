"""
Manual migration helpers for complex schema changes. 
These run after SQL migrations and handle operations that are too complex
for Render's SQL parser (like conditional schema alterations).
"""

from sqlalchemy. ext.asyncio import AsyncEngine
from sqlalchemy import text
import logging

logger = logging.getLogger(__name__)


async def enable_pg_trgm_extension(engine: AsyncEngine) -> dict:
    """
    Enable pg_trgm extension for text search capabilities.
    
    Returns:
        dict with 'success' boolean and 'message' string
    """
    try:
        async with engine.begin() as conn:
            # Check if extension exists
            result = await conn. execute(text(
                "SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm'"
            ))
            exists = result.scalar() is not None
            
            if exists:
                return {
                    'success': True,
                    'message': 'pg_trgm extension already enabled',
                    'action': 'skipped'
                }
            
            # Try to create extension
            try:
                await conn.execute(text("CREATE EXTENSION IF NOT EXISTS pg_trgm"))
                return {
                    'success': True,
                    'message': 'pg_trgm extension created successfully',
                    'action': 'created'
                }
            except Exception as ext_error:
                # Extension creation failed (probably insufficient privileges)
                logger.warning(f"Could not create pg_trgm extension: {ext_error}")
                return {
                    'success': False,
                    'message': f'pg_trgm extension not available: {str(ext_error)}',
                    'action': 'failed',
                    'note': 'Text search will use basic matching instead'
                }
                
    except Exception as e:
        logger.error(f"Error checking pg_trgm extension: {e}")
        return {
            'success': False,
            'message': f'Error: {str(e)}',
            'action': 'error'
        }


async def align_journal_entries_schema(engine: AsyncEngine) -> dict:
    """
    Align journal_entries. id from legacy INTEGER to VARCHAR(64) if needed.
    This handles upgrades from old schemas. 
    
    Returns:
        dict with 'success' boolean, 'message' string, and 'action' taken
    """
    try:
        async with engine.begin() as conn:
            # Check if journal_entries table exists
            result = await conn.execute(text("""
                SELECT column_name, data_type, character_maximum_length
                FROM information_schema.columns
                WHERE table_schema = current_schema()
                  AND table_name = 'journal_entries'
                  AND column_name = 'id'
            """))
            
            row = result.fetchone()
            
            if not row:
                # Table doesn't exist yet - will be created by SQL migration
                return {
                    'success': True,
                    'message': 'journal_entries table not found - will be created by SQL migration',
                    'action': 'skipped'
                }
            
            col_type = row[1]
            col_length = row[2]
            
            # Check if already correct type
            if col_type == 'character varying' and col_length == 64:
                return {
                    'success': True,
                    'message': 'journal_entries. id already VARCHAR(64)',
                    'action': 'skipped'
                }
            
            # Need to convert from INTEGER or wrong VARCHAR length
            logger.info(f"Converting journal_entries.id from {col_type} to VARCHAR(64)")
            
            # Drop dependent foreign keys
            await conn.execute(text("""
                ALTER TABLE journal_entry_tags 
                DROP CONSTRAINT IF EXISTS journal_entry_tags_entry_id_fkey
            """))
            await conn. execute(text("""
                ALTER TABLE journal_versions 
                DROP CONSTRAINT IF EXISTS journal_versions_entry_id_fkey
            """))
            await conn.execute(text("""
                ALTER TABLE journal_search_index 
                DROP CONSTRAINT IF EXISTS journal_search_index_entry_id_fkey
            """))
            
            # Check if emotional_reset_sessions table exists
            check_ers = await conn.execute(text("""
                SELECT 1 FROM information_schema.tables 
                WHERE table_schema = current_schema()
                  AND table_name = 'emotional_reset_sessions'
            """))
            if check_ers.scalar():
                await conn.execute(text("""
                    ALTER TABLE emotional_reset_sessions 
                    DROP CONSTRAINT IF EXISTS emotional_reset_sessions_journal_entry_id_fkey
                """))
            
            # Convert all foreign key columns
            await conn.execute(text("""
                ALTER TABLE journal_entry_tags 
                ALTER COLUMN entry_id TYPE VARCHAR(64) USING entry_id::VARCHAR(64)
            """))
            await conn.execute(text("""
                ALTER TABLE journal_versions 
                ALTER COLUMN entry_id TYPE VARCHAR(64) USING entry_id::VARCHAR(64)
            """))
            await conn. execute(text("""
                ALTER TABLE journal_search_index 
                ALTER COLUMN entry_id TYPE VARCHAR(64) USING entry_id::VARCHAR(64)
            """))
            
            if check_ers.scalar():
                await conn.execute(text("""
                    ALTER TABLE emotional_reset_sessions 
                    ALTER COLUMN journal_entry_id TYPE VARCHAR(64) 
                    USING journal_entry_id::VARCHAR(64)
                """))
            
            # Convert primary key column
            await conn.execute(text("""
                ALTER TABLE journal_entries 
                ALTER COLUMN id TYPE VARCHAR(64) USING id::VARCHAR(64)
            """))
            
            # Recreate primary key
            await conn.execute(text("""
                ALTER TABLE journal_entries 
                DROP CONSTRAINT IF EXISTS journal_entries_pkey
            """))
            await conn.execute(text("""
                ALTER TABLE journal_entries 
                ADD CONSTRAINT journal_entries_pkey PRIMARY KEY (id)
            """))
            
            # Restore foreign keys
            await conn.execute(text("""
                ALTER TABLE journal_entry_tags 
                ADD CONSTRAINT journal_entry_tags_entry_id_fkey 
                FOREIGN KEY (entry_id) REFERENCES journal_entries(id) ON DELETE CASCADE
            """))
            await conn.execute(text("""
                ALTER TABLE journal_versions 
                ADD CONSTRAINT journal_versions_entry_id_fkey 
                FOREIGN KEY (entry_id) REFERENCES journal_entries(id) ON DELETE CASCADE
            """))
            await conn.execute(text("""
                ALTER TABLE journal_search_index 
                ADD CONSTRAINT journal_search_index_entry_id_fkey 
                FOREIGN KEY (entry_id) REFERENCES journal_entries(id) ON DELETE CASCADE
            """))
            
            if check_ers.scalar():
                await conn.execute(text("""
                    ALTER TABLE emotional_reset_sessions 
                    ADD CONSTRAINT emotional_reset_sessions_journal_entry_id_fkey 
                    FOREIGN KEY (journal_entry_id) REFERENCES journal_entries(id) 
                    ON DELETE SET NULL
                """))
            
            return {
                'success': True,
                'message': f'Successfully converted journal_entries.id from {col_type} to VARCHAR(64)',
                'action': 'converted',
                'from_type': col_type
            }
            
    except Exception as e:
        logger.error(f"Error aligning journal_entries schema: {e}")
        return {
            'success': False,
            'message': f'Error: {str(e)}',
            'action': 'error'
        }


async def run_manual_migrations(engine: AsyncEngine) -> dict:
    """
    Run all manual migrations in sequence.
    
    Returns:
        dict with results for each migration
    """
    results = {}
    
    logger.info("Running manual migrations...")
    
    # Enable pg_trgm extension
    results['pg_trgm'] = await enable_pg_trgm_extension(engine)
    logger.info(f"pg_trgm: {results['pg_trgm']['message']}")
    
    # Align journal schema if needed
    results['journal_alignment'] = await align_journal_entries_schema(engine)
    logger.info(f"journal_alignment: {results['journal_alignment']['message']}")
    
    return results
